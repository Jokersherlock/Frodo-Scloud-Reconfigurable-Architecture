# 存储系统

存储系统由**Bank RAM**,**Accumulator**和**Bus**组成

## Bank RAM

由5块32*512的单端口RAM组成

### S,S'的存储

补码符号位占其中一个Bank(32个)，剩下4个bank存储32个数据，每个4bit。

横向上(160bit),存储长边连续的32个数

纵向按短边连续存储

其余时候可作为正常的单端口RAM进行读写

## Accumulator区

共16块,每块为64*336的伪双端口RAM

分为4组，每组4个

存在两种读写模式

**mode 0**:写覆盖模式,此时使用读端口正常读数据,写端口会将结果直接写入ram中

**mode 1**:写累加模式,此时读端口将ram数据取出,加上输入的数据,再存储ram中,内部是一个流水线,因此可持续进行

### A的缓存

16块分为前8块和后8块,A将使用空闲的8块进行缓存

8块可分为前4块和后4块,每次A将读一大块,写一大块

A的一行写入到1块中

因此在读取A时,每次读取出A的4*4的大小,可供1个engine使用

### B/E的存储

根据MMU的设计情况待定,只需1个B占据其中8块即可

# MMU

## 细节

共8个engine，每个engine 4个PE，每个PE 1个lane

左乘计算$$4*n\times n*\bar{n}$$

左乘的最终结果是$$m*\bar{n} $$

每轮计算$$4*4\times 4*\bar{n}$$,共8个

因此A需要4*32个,S一次需要4*8=32个(源于S的一列???)

单轮内S切换列进行

每个lane配备2/4个累加寄存器,当目标累加与上一次的不同时,发出替换请求,所有lane替换使能时进行替换

8个engine对应的PE需要加法树连接,每次替换输出$$4*1$$的结果

右乘计算$$\bar{m} *4 \times 4*n$$

右乘的结果是$$\bar{m}*n$$

每轮计算$$\bar{m} *4 \times 4*4 $$共8个

A还是需要4*32个,不过需要8个转置单元?

S始终为$$\bar{m}*4$$,所有的一样.一次只需要4个

替换策略相同

每次替换直接输出$$1*32的结果$$个数 是结果的1个维度的数据(考虑到Scloud计算周期小于等于2,所以不能缓冲输出)

MMU由N组Engine组成,每个Engine由一个Slice(矩阵切片模块),5个Fifo,M个PE,1个加法树组成

每个PE有T个计算通道.

暂时取N=3/4,M=4,T=2

## 左乘

$$AS+E,设A为m\times n,S为n\times \bar{n}$$

```Python
for i in range(m/4): #最外层循环,A每次缓存4行
    a[0] = A[4*i]
    a[1] = A[4*i+1]
    a[2] = A[4*i+2]
    a[3] = A[4*i+3]
    for j in range(n/4N):#第二层循环,对单个PE,每次计算S的4行
        #单个PE计算 1*4  4*nbar
        #单个engin计算 4*4 4*nbar
        #整个MMU计算 4*4N 4N*nbar
        s[0] = S[4*j]
        s[1] = S[4*j+1]
        s[2] = S[4*j+2]
        s[3] = S[4*j+3]
        transrows = slice(s_T)
        #对于Frodo,transrow有40行,对于Scloud128/192,有16行,对于Scloud256,有22行(为什么会有11这种数字)
        #准备4个累加器吧,写成类cache结构
        #4个PE用同一个transrows计算A的4行
        #不同Engine之间,计算S的不同行
        #结果为B的一行
```

输入带宽:

S: 输入S 1列的4N个，输入nbar次

A:一次内层循环需要4*4N个A。每个PE接A一行的4个

输出带宽

写成类cache结构只需最后写入(每轮外循环输出一次)

### 研究一下过程的B/E

每次其实就是计算了4*nbar

最多11种结果而已

整个过程只换A和S，B/E不动

## 右乘

$$S'A+E',设S'为 \bar{m}\times m,A为m\times n$$

```Python
for i in range(m/4): #最外层循环,A每次缓存4行
    a[0] = A[4*i]
    a[1] = A[4*i+1]
    a[2] = A[4*i+2]
    a[3] = A[4*i+3]
    a = a^T
    #一次进行 mbar * 4 4*n
    #因此一次其实只能看到S'的4列
    for j in range(n/4N):#第二层循环,对单个PE,每次计算A的1列,一个transrow应该来自S'的一行
        #单个PE计算mbar *4  4*1
        #单个engine计算 mbar*4 4*4
        #整个MMU计算 mbar*4 4*4N
        s[0] = S[4*j]
        s[1] = S[4*j+1]
        s[2] = S[4*j+2]
        s[3] = S[4*j+3]
        transrows = slice(s)
        #对于Frodo,transrow有40行,对于Scloud128/192,有16行,对于Scloud256,24行
        #准备4个累加器吧,写成类cache结构
        #4个PE用同一个transrows计算A的4个不同列
        #不同Engine之间,transrows实际上是共用的,计算A的不同列
```

输入带宽

每次输入S'的1行的4个数，然后所有的共用，输入mbar次

每个PE需要A的一列的4个，一下要4N个

输出带宽

输出4N个一次

内层循环就需要输出,但是,内层循环的暗含循环每次严格4个累加结果

### 研究一下过程的B/E

每轮的最终结果是mbar*n（其实就是全部）

单个PE看到mbar个，单个engine看到mbar*4个

所以在一次transrow中，每个PE内部其实很简单，关键是算完后mbar*4N个的替换

double一下（）

计算时输出上次结果

有点幽默了

**方案1** ：寄存器double

4N*12*16bit = 3072!

**方案2** ：类cache结构

甚至能减少原需的寄存器，但是要考虑好替换策略，不然对latency影响很大

**方案3** ：大带宽B/S

需要伴随较为复杂的存储规划、地址生成

**方案4** ：不使用fifo,直接5个计算单元

lut的开销应该会很大，并且和hash速度严重不匹配（但是也许可以加速hash?）

engine数减半就可以了（但此时1344的差距比带fifo的大一点）

取engine=3倒是合理一点，但是控制麻烦

目前应该方案4更好一点

# 指令设计

## MMU相关

一个矩阵乘指令应当完整的完成4行A的乘法

参数需求：A的行号

